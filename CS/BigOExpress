## 시간 복잡도
- 시간 복잡도란?
  - 우리가 작성한 코드는 실행시간이 얼마나 걸릴가?  
  실행해보기 전에 정확한 시간을 추측하는 것은 힘들겠지만  
  반복문을 몇 번 사용했는지, 입력 값은 어떻게 되는지 등을 통해 대략적으로 이 정도 되겠구나..를 추측할 수 있다.  
  즉, 우리는 입력값과 연산 수행 시간의 상관 관계를 나타내는 척도를 시간 복잡도라고 한다.

- Big-O 표기법
  - 같은 알고리즘을 가지고 테스트하더라도 입력 값이 달라짐에 따라 수행 시간은 매우 짧아질 수도, 매우 길어질 수도 있다.  
  
  - 
     |2|1|3|4|5|6|7|8|9|10|
        |---|---|---|---|---|---|---|---|---|---|
        |O|O|
  - 예를 들어 10개의 배열에 위처럼 숫자가 들어가 있다고 치자.
  이 숫자를 오름차순으로 정렬하려면 '2'와 '1'만 바꿔주면 된다. 수행 시간이 아주 짧을 것이다.  

  - |10|9|8|7|6|5|4|3|2|1|
    |---|---|---|---|---|---|---|---|---|---|  
  
  만약 숫자가 이런식으로 들어가 있다고 하면?
  분명 수행 시간은 더 오래 걸릴 것이다. 오름차순 정렬하기에는 가장 최악의 상황이다.  
  시간 복잡도는 보통 이런 최악의 상황일 때 걸리는 시간을 이용해 나타낸다.  
  그리고 이걸 Big-O 표기법이라고 한다.
> 그 외 다른 표기법은 여기에서확ㅇ니 할 수 있다.
> 하지만 거의 대부분은 Big-O 표기법을 이용해 시간 복잡도를 나타낸다.
>
- 자료의 수에 따른 실행시간 변화
  - ```java
    class Ex{
    public static void main(String[] args){
      for(int i = 0; i < n; i++) {
        System.ou.println(n);
      }
    }
    } 
    ```
    - 위 코드는 n번을 반복하면서 값을 출력하는 예제이다.  
    즉, 자료의 수는 n 개이며 Big-O 표기법에 따라 O(n)이라고 나타낼 수 있다.
    - ![img_1.png](img_1.png)
    - 자료의 수가 증가함에 따라 소요되는 처리시간 증가율을 그래프로 나타낸 것이다.  
    빨간색영역에 가까워질수록 수행시간이 굉장히 오래 걸리는 알고리즘이라고 할 수 있고,  
    초록색에 가까워질수록 수행 시간이 짧은 알고리즘이라 할 수 있다.  
    각각에 대한 예제는 [목차 2]에서 이어서 보자.
- 예제
  - 2-1 O(1)
  - ```java
    if(n%2 == 0){
        System.out.println("짝수");
    }else{
        System.out.println("홀수");
    }
    ```
  - 위의 예제는 입력학 n이 짝수면 한 단계에 걸쳐 수행이 완료되었을 것이고,  
  홀수면 두 단계에 걸쳐 수행이 완료되었을것이다.  
  하지만 우리는 이걸 O(1), O(2)이렇게 나누지 않고 전부 O(1)으로 나타낸다.  
  앞으로 나올 예제들에 비하면 터무니 없이 작은 차이이기 때문에 이런 상수들은 전부 O(1)로 나태는것이라 생각하면 된다.
    
> O(1)과 O(2)의 차이에 대한 의견들은 여기에서 확인할 수 있다.
  - 2-2 O(n)
  - ```java
    for(int i=0; i<n; i++){
    System.out.println(n);
    }
    ```
  - 반복문을 이용해 n번 반복한다면 이는 Big-O 표기법으로 O(n)이라 나타낼 수 있다.  
  n의 값에 따라 처리수도 1:1 비례해서 늘어난다.
  - 2-3 O(n^2)
  ```java 
  for(int i=0; i<n; i++){
   for(int j =0; j<n; j++){
    System.out.println(n * j);
   }
   }
  ```
반복문이 두 번 겹쳐져 있는 이중 반복문의 경우 O(n2^2)으로 나타낼 수 있다.
  - 2-4 O(n^3)
    - ```java
      for(int i=0; i<n; i++){
        for(int j=-; j<n; j++){
            for(int k = 0; k<n; k++){
            System.out.println(n * j + k);
             }
          }
      }
      ```
      당연하게도 반복문 세개가 겹치면 O(n^3)이고 이런식으로 얼마든지 반복문을 겹칠 수 있겠으나  
    시간 복잡도가 O(n^2)만 넘어도 코딩테스트에선 시간초과가 뜬다. 
  - 2-5 O(nm)
    - ```java
      for (int i=0; i<n; i++){
      for(int j=0; j<m; j++){
      System.out.println(n * m );
        }
      }
      ```
      얼핏 보면 [목차 2-3] 과 같은 이중 포문 같지만 엄연히 다르다.  
      n번 반복하는 반복문을 두 번 중첩 시킨것이 아니라 n번 반복문과 m번 반복문을 중첩 시켰다.
      막말로 n이 9999999999인데 m은 1일 수도 있기 때문에 [목차2-3]과 달리 O(nm)이라고 나타내 주어야 한다.
  - 2-6 O(2^n)
  - ```java
      public static int pibo(int n){
        if(n == 0) return 0;
        else if (n == 1 ) return 1;
     
     return pibo(n - 1) + pibo (n - 2);
     }
     ```
     위 코드는 피보나치수열을 구현한 것이다.  
    pibo(n)을 호출하면 pino(n-1) 과 pibo(n-2)가 호출된다.
    그리고 이 호출 작업은 총 n번 반복되기 때문에 이를 Big-O표기법으로 나타내면 O(2^n)이 된다.
  - 2-7  O(logn)
  - ```java
    public static int binarySearch(int[] num, int target, int low, int high){
        int mid = (low + high)/2;
        if(target == num[mid]) return mid;
        else if (target < num[mid]) return binarySearch(num, target, low, mid-1);
        else return binarySearch(num, target, mid+1 , high);
    }
    ```
    위 코드는 이진 탐색 기법을 코드로 구현한 것이다.  
    탐색을 해나갈수록 탐새갷야 할 데이터가 절반으로 뚝뚝 떨어지기 때문에
    이를 Big-O 표기법으로 나타내면 O(logn)이 된다.
    
    
- 대략적인 소요시간 추측하기  
    O() <- 괄호 안에 들어가는 식을 계산해서 1억당 1초 정도로 생각할 수 있다고 한다.  
    예를 들어 n이 1억인데 시간 복잡도가 O(n)이면 소요시간이 1초 정도 걸린다는 뜻이다.  
    n이 1억, m이 10, 시간 복잡도가 O(nm)이면 소요시간이 10초가 된다는 것이다.  
