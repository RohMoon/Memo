

* flexbox
  `flexbox` 는 CSS 속성에 `display:flex`를 추가하면 사용할 수 있는 것인데, 인터페이스 내의 아이템 간 공간 배분과 강력한 정렬 기능을 제공하기 위한 1차원 레이아웃 모델로 설계 되었다.  
  `flexbox`를 1차원이라 칭하는 것은, 레이아웃을 다룰 때 한번에 하나의 차원(행이나 열)만 다룬다는 뜻입니다.  
  이는 행과 열을 함께 조절하는 CSS 그리드 레이아웃의 2차원 모델과는 대조된다.  
  `flexbox`를 다루려면 주축과 교차축이라는 두 개의 축에 대한 정의를 알아야 한다. 주축은 `flex-direction` 속성을 사용하여 지정하며 교차축은 이에 수직인 축으로 결정됩니다.  
  `flexbox`의 동작은 결국 이 두 개의 축에 대한 문제로 환원된다.
    - **주축**  
      주축은 `flex-direction`에 의해 정의되며 4개의 값을 가질 수 있다.
        - `row`
        - `row-reverse`
        - `column`
        - `column-reverse`  
          `row` 혹은 `row-reverse`를 선택하면 주축은 ___인라인 방향___ 으로 행을 따른다.
          `column` 혹은 `column-reverse`을 선택하면 주축은 페이지 상단에서 하단으로 ___블록 방향___ 을 따릅니다.

    - **교차축**  
      교차축은 주축에 수직하므로, 만약 `flex-direction`(주축)이 `row`나 `row-reverse`라면 교차축은 열 방향으로 따른다.  
      주축이 `column` 혹은 `column-reverse`라면 교차축은 행 방향으로 따른다.
      flex 요소를 정렬하고 끝을 맞추려면(justify) 어느 축이 어느 방향인지 이해하는 것이 중요하다. `flexbox`는 주축, 교차축을 따라 항목을 정렬하고 끝을 맞추는 각종 속성들을 적용하는 방식으로 동작한다.

    - **시작선과 끝선**
      `flexbox`가 쓰기 방법(writing mode)을 가정하지 않는다는 사실이 중요하다. 과거 CSS 는 왼족에서 오른쪽으로 향하는 가로 방향의 쓰기 방법에 치우쳐 있었다.  
      하지만, 현대의 레이아웃은 다양한 쓰기 방법을 포괄해야 하므로, 더 이상 텍스트가 문서의 왼쪽 상단에서 시작해서 오른쪽으로 향한다고도, 새 라인이 항상 아래에 쌓인다고도 가정하지도 않는다.
      다른 글에서 `flexbox`와 쓰기 방법 명세가 어떤 관련이 있는지 알아보기 전에 `flex` 요소의 정렬 방향에 "좌우상하"를 사용하지 않는 이유를 알 수 있어야한다.  
      `flex-direction`이 `row`고 영어 문장을 문서에 쓰고 있다면, 주축의 시작선은 왼쪽 끝, 끝선은 오른쪽 끝이 될 것이다.  
      아랍어 문장을 쓰고 있다면 주축의 시작선은 오른쪽 끝, 끝 선은 왼쪽이 될것이다.  
      영어와 아랍어는 모두 가로 쓰기를 채택하고 있으므로 두 예시에서 교차축의 시작선은 ___flex 컨테이너___ 의 위끝이며 끝선은 아래 끝이다.

    - flex 컨테이너  
      문서의 영역 중에서 `flexbox`가 놓여있는 영역을 `flex 컨테이너`라고도 부른다. flex 컨테이너를 생성하려면 영역 내의 컨터이너 요소의 `display`값을 `flex`혹은 `inline-flex`로 지정한다.  
      이 값을 지정된 컨테이너의 일차 자식(direct children)요소가 ___flex 항목___ 입니다.  
      `display` 속성만 지정하여 `flex` 컨테이너를 생성하면 다른 flex 관련 속성들은 아래처럼 기본 값이 지정된다.
        - 항목은 행으로 나열된다 . (`flex-direction` 속성의 기본값은 `row`입니다.)
        - 항목은 주축의 시작 선에서 시작합니다.
        - 항목은 주 차원 위에서 늘어나지는 않지만 줄어들 수 잇습니다.
        - 항목은 교차축의 크기를 채우기 위해 늘어납니다.
        - `flex-basis` 속성은 `auto`로 지정된다.
        - `flex-wrap` 속성은 `nowrap`으로 지정된다.

이렇게되면 ___flex항목___ 들은 각 항목 별 내부 요소의 크기로 주축을 따라 정렬된다. 컨테이너의 크기보다 더 많은 항목이 있을 경우 행을 바꾸지 않고 주축 방향으로 흘러 넘치게 된다. 어떤 항목이 다른 항목보다 높이 값이 크다면 나머지 모든 항목들은 그에 맞게 교차축에 따라 늘어나게 됩니다.

- flex-direction 지정  
  ***flex 컨테이너*** 에 `flex-direction` 속성을 지정하면 flex 항목이 나열되는 방향을 변경할 수 있다. `flex-direction : row-reverse`라고 지정하면 행으로 나열되는 것은 그대로지만 시작 선과 끝 선이 서로 바뀌게 됩니다.

- flex-wrap을 이용한 복수 행 flex 컨테이너 지정
  `flexbox`는 1차원 모델이지만 ___flex 항목___ 이 여러 행에 나열되도록 할 수 있습니다. 그 경우 각 행이 새로운 ___flex 컨테이너___ 라고 생각해야 한다. 공간 배분은 해당 행에서만 이루어지며 다른 행은 영향을 받지 않는다.

항목이 여러 행에 나열되도록 하려면 `flex-wrap`속성의 값을 `wrap`으로 지정한다. 그러면 항목이 하나의 행에 들어가지 않을 정도로 클 경우 다른 행에 배치된다.

- 축약형 속성 flex-flow
  `flex-direction` 속성과 `flex-wrap`속성을 `flex-flow`라는 축약 속성으로 합칠 수 있다. 첫번 째 값은 `flex-direction`이고 두 번째 값은 `flex-wrap`입니다.

- flex 항목에 지정 가능한 속성들
  ___flex 항목___ 에 적용할 수 있는 속성은 다음과 같다.
    - `flex-grow  `
    - `flex-shrink`
    - `flex-basis `

500 픽셀의 크기를 갖는 flex컨테이너 내에 100픽셀 크기의 자식 세 개가 존재할 때, 사용가능한 공간 200픽셀이 남게 된다. 기본적으로 `flexbox`는 이 공간을 마지막 자식 요소 다음에 빈공간을 남겨둔다.

위의 `flex-grow`, `flex-shrink`, `flex-basis` 이 세 가지 속성을 변경한다는 것은 ___flex 항목___ 에게 사용가능한 공간을 분배하는 방식을 변경하는 것이다.  
___사용가능한 공간___ 개념은 ___flex항목___ 을 정렬할 때 특히 중요하다.

#### flex-basis 속성
`flex-basis` 속성은 항목의 크기를 결정한다. 이 속성의 기본값은 `auto`이며, 이 경우 브라우저는 항목이 크기를 갖는지를 확인한다.

___flex 항목___ 에 크기가 지정되어 있지 않으면, ___flex 항목___ 의 내용물 크기가 flex_basis 값으로 사용된다. 따라서 ___flex 컨테이너___ 에서 `display: flex`속성만을 지정하면 flex 항목들이 각 내용물 크기만큼 공간을 차지하게 된다.

#### flex-grow 속성
`flex-frow` 값을 양수로 지정하면 ___flex항목___ 별로 주축 방향 크기가 `flex-basis`값 이상으로 늘어날 수 있게 된다. 예를 들어 모든 항목의 flex-grow 값을 1로 지정하면 사용가능한 공간은 각 항목에게 동일하게 분배되며, 각 항목은 주축을 따라 분배 받은 값만큼 사이즈를 늘려 공간을 차지한다.

첫 항목의 `flex-grow` 값을 2로 지정하고 나머지 두 개의 항목을 1로 지정한다면 각 항목에 지정된 `flex-grow` 값의 비율에 따라 남은 공간이 분배된다. 각 항목의 `flex-grow`비율이 2:1:1 이므로 첫 항목에게 100픽셀, 두 번째와 세 번째 항목에게 50픽셀씨 분배된다.

#### flex-shrink 속성
`flex-frow`소겅이 주축에서 남는 공간을 항목들에게 분배하는 방법을 결정한다면 `flex-shrink` 속성은 주축의 공간이 부족할때 각 항목의 사이즈를 줄이는 방법을 정의한다. 만약 ___flex 컨테이너___ 가 ___flex항목___ 을 모두 포함할 만큼 넉넉한 공간을 갖고 있지 않고 `flex-shrink`값이 양수 이면 ___flex 항목___ 은 flex-basis에 지정된 크기보다 작아진다.  
또한 `flex-grow`속성과 마찬가지로 더 큰 `flex-shrink`값을 갖는 항목의 사이즈가 더 빨리 줄어듭니다.

항목의 최소 크기는 실제 축소량을 계산할 때 고려되기 때문에 flex-shrink 속성이 flex-grow 속성에 비해 덜 일관된 모습을 보여줄지도 모릅니다.
> `flex-grow`와 `flex-shrink`의 값이 비율임을 유의해야한다고 한다.  ___flex 항목___ 의 flex 속성을 `1 1 200px` 로 지정하고 한 항목만 크기가 늘어나는 비율을 타 항목의 두배로 하고 싶으면 해당 ___flex항목___ 의 flex속성을 `2 1 200px` 로 지정하면 되지만,
> flex 속성 값을 모두 `10 1 200px`로 지정하고 늘어나는 비율을 두 배로 하고 싶은 항목의 flex 속성 값만 `20 1 200px` 로 지정해도 동일하게 동작한다.

#### 축약형 속성 flex
보통은 `flex-grow`, `flex-shrink`, `flex-basis` 값을 각각 사용하지 않고 이 세 속성을 한번에 지정하는 `flex` 축약형을 많이 사용합니다.  `flex` 축약형의 값은 `flex-grow`, `flex-shrink`, `flex-basis`순서로 지정된다.
flex 축약형 표현에 사용할 수 있는 미리 정의된 축약 값들이 아래에 나열되어 있다. 이 값들만으로도 대부분의 경우 (use-case)에 대응할 수 있을 것이다.
- `flex:initial`
- `flex:auto`
- `flex:none`
- `flex:<positive-number>`

___flex 항목___ 을 `flex:initial`로 지정하면 `flex : 0 1 auto`로 지정한 것과 동일하게 동작한다.
이 경우, ___flex 항목___ 들을 `flex-grow`가 0이므로 `flex-basis` 값보다 커지지 않고 `flex-shrink`가 1이므로 ___flex 컨테이너___ 공간이 모자라면 크기가 줄어든다.
또, `flex-basis`가 `auto`이므로 ___flex항목___ 은 주축 방향으로 지정된 크기 또는 자기 내부 요소 크기 만큼 공간을 차지한다.


`flex:auto` 로 지정하면 `flex :1 1 auto`로 지정한 것과 동일하며, `flex:initial`과는 주축 방향 여유 공간이 있을 때 ___flex 항목___ 들이 늘어나서 주축 방향 여유 공간을 채우는 점만 다르다.

`flex:auto`로 지정하면 `flex : 0 0 auto`으로 지정한것과 동일하며 ___flex 컨테이너___ 의 크기 변화에도 ___flex 항목___ 크기는 변하지 않고 `flex-basis`를 `auto`로 지정했을 때 정해지는 크기로 결정된다.

이 축약형은 더 축약해서 `flex:1`이나 `flex:2`처럼 쓸 수도 있는데, 이는 `flex-grow`만 지정하고 나머지는 1 0으로 사용한다는 뜻이다. 따라서 `flex:2`는 `flex:2 1 0`과 동일하게 처리된다.

#### 정렬 끝 맞추기(justfication), flex 항목간 여유 공간 분배
`flexbox`의 주 기능 중 하나는 (주축과 교차축으로 표현되는) ___flex 컨테이너___ 공간 안에 ___flex 항목___ 들을 정렬하고 끝 마추며 여유 공간을 항목 간에 분배하는 것이다.

역주 ) 이 절의 내용은 ___flex 컨티에너___ `flex-direction`을 row로 가정하고 '행'과'열'로 표기했습니다.

####`algin-items`
`align-items`는 ___flex 컨테이너___ 에 지정하는 속성이며, 교차축을 따라 ___flex 항목___ 열을 정렬하는 방식을 지정한다.

이 속성의 (아무것도 지정하지 않았을 경우 적용되는 ) 초기 값은 `strech` 이며 이 값을 지정하면 ___flex 항목___ 의 높이는 ___flex 컨테이너___ 내 ___flex 항목___ 행의 최대 높이로 지정된다 . 따라서 ___flex 항목___ 행이 하나 일 때는 ___flex 항목___ 은 교차축 방향으로 ___flex 컨테이너___ 를 가득 채우게 된다.

이 속성을 `flex-start`로 지정하면 ___flex 항목___ 의 첫 열이 교차축 방향의 시작선에 정렬된다. `flex-end`로 지정하면 ___flex 항목___ 의 첫 열이 교차축 방향의 끝 선에 정렬된다.
`center`로 지정하면 ___flex 항목___ 행에 배분된 공간의 가운데 라인에 정렬된다.

#### justify-content
`justify-content` 속성은 주축을 따라 ___flex 항목___ 행을 정렬하는 방식을 지정합니다.

이 속성의 (아무것도 지정하지 않았을 때 적용되는 ) 초기 값은 `flex-start`이며 이 값을 지정하면 ___flex 항목___ 행 내의 항목들은 ___flex 컨테이너___ 의 시작선에서 부터 정렬된다. `flex-end`로 지정하면 ___flex 항목___ 행의 마지막 항목이 ___flex 컨테이너___ 의 끝선에서 정렬된다. `center`로 지정하면 ___flex항목___ 들이 ___flex 항목___ 행의 가운데에 정렬된다.

`space-between`을 지정하면 주축 방향 여유 공간을 ___flex 항목___ 사이의 공간에 균등 배분합니다.

`space-around`는 시작선 및 끝 선과 ___flex 항목___ 간의 공간도 균등 배분에 고려하므로 시작선 및 끝선과 ___flex 항목___ 간의 공간의 크기를 1로 배분한다면 ___flex 항목___ 사이의 공간 및 시작선 및 끝선과 ___flex 항목___ 간의 공간의 크기를 1로 배분하나면 ___flex 항목___ 사이의 공간은 2로 배분한다.

`space-evenly`로 지정하면 여유 공간을 ___flex 항목___ 사이의 공간 시작선 및 끝선과 ___flex 항목___ 간의 공간에 모두 균등하게 배분합니다. 


